<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode2：两数相加</title>
    <link href="undefined2019/12/05/LeetCode2%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>2019/12/05/LeetCode2%EF%BC%9A%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-2：-两数相加"><a href="#LeetCode-2：-两数相加" class="headerlink" title="LeetCode 2： 两数相加"></a><div align="center">LeetCode 2： 两数相加</div></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例</strong><br><strong>输入</strong>：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><strong>输出</strong>：7 -&gt; 0 -&gt; 8<br><strong>原因</strong>：342 + 465 = 807</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="solution1"><a href="#solution1" class="headerlink" title="solution1:"></a>solution1:</h4><p>就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 $l1$ 和 $l2$ 的表头开始相加。由于每位数字都应当处于 $0 \ldots …9$ 的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，$5 + 7 = 12$ 。在这种情况下，我们会将当前位的数值设置为 $2$ ，并将进位 $carry = 1$ 带入下一次迭代。进位 $carry$ 必定是 $0$ 或 $1$，这是因为两个数字相加（考虑到进位）可能出现的最大和为 $9 + 9 + 1 = 19$ 。</p><p>伪代码如下：</p><ul><li>将当前结点初始化为返回列表的哑结点。</li><li>将进位 $carry$ 初始化为 $0$。</li><li>将 $p$ 和 $q$ 分别初始化为列表 $l1$ 和 $l2$ 的头部。</li><li>遍历列表 $l1$ 和 $l2$ 直至到达它们的尾端。</li><li>将 $px$设为结点 $p$ 的值。如果 $p$ 已经到达 $l1$ 的末尾，则将其值设置为 $0$。</li><li>将 $qx$设为结点 $q$ 的值。如果 $q$ 已经到达 $l2$ 的末尾，则将其值设置为 $0$。</li><li>设定 $sums = px + qx + carry$ 。</li><li>更新进位的值，$carry = sums / 10$ 。</li><li>创建一个数值为 $(sum \bmod 10)$ 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。</li><li>同时，将 $p$ 和 $q$ 前进到下一个结点。</li><li>检查 $carry = 1$ 是否成立，如果成立，则向返回列表追加一个含有数字 $1$ 的新结点。</li><li>返回哑结点的下一个结点。</li></ul><p>请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。</p><h4 id="solution2"><a href="#solution2" class="headerlink" title="solution2:"></a>solution2:</h4><p>使用递归的思想</p>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1： 两数之和</title>
    <link href="undefined2019/12/03/LeetCode1%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>2019/12/03/LeetCode1%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-1：-两数之和"><a href="#LeetCode-1：-两数之和" class="headerlink" title="LeetCode 1： 两数之和"></a><div align="center">LeetCode 1： 两数之和</div></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 $nums$ 和一个目标值 $target$，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong><br> 给定 $nums = [2, 7, 11, 15], target = 9$</p><p> 因为 $nums[0] + nums[1] = 2 + 7 = 9$<br> 所以返回 $[0, 1]$</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想:"></a>思想:</h2><p>寻找 $target-nums$，</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><ul><li>用两层循环，时间复杂度 $o(n^2)$</li><li>使用List中相关函数，在每次循环中查找索引，本质上依然是 $o(n^2)$ 的时间复杂度</li></ul><h4 id="solution1"><a href="#solution1" class="headerlink" title="solution1:"></a>solution1:</h4><p>在每次循环中顺序查找,但当出现重复数字时，第一次查找只会找到自身，只有第二次查找时才能得到结果。</p><p><strong>示例:</strong><br> 给定 $nums = [3, 7, 11, 3], target = 6$</p><p> 只有第二次查找时，才会返回结果</p><pre><code class="python">def twoSum(nums, target):    for inx, num1 in enumerate(nums):        num2 = target - num1        if num2 in nums and nums.index(num2) != inx:            return [inx, nums.index(num2)]    return []</code></pre><h4 id="solution2"><a href="#solution2" class="headerlink" title="solution2:"></a>solution2:</h4><p>$num2$ 的查找并不需要每次从 $nums$ 查找一遍，只需要从<font color="#0000ff"> $num1$ 位置之前或之后查找</font>即可。</p><pre><code class="python">def twoSum(nums, target):    for inx, num1 in enumerate(nums):        num2 = target - num1        temp = nums[:inx]        if num2 in temp:            return [nums.index(num2), inx]    return []</code></pre><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li>将数组值作为键，索引作为值存入哈希表，遍历数组，判断 $target-nums$ 是否存在表中</li><li>时间复杂度 $o(n)$</li><li>空间复杂度 $o(n)$</li></ul><h4 id="solution3："><a href="#solution3：" class="headerlink" title="solution3："></a>solution3：</h4><p><strong><font color="#0000ff"> 一遍哈希表</font></strong></p><p>在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p><pre><code class="python">def twoSum(nums, target):    hashmap = {}    for inx, num1 in enumerate(nums):        if target - num1 in hashmap:            return [hashmap[target - num1], inx]        hashmap[num1] = inx</code></pre><h4 id="solution4"><a href="#solution4" class="headerlink" title="solution4:"></a>solution4:</h4><p>引入解决冲突的办法，将哈希表的值设为List对象，当键出现冲突时，用类似链地址法把同义的键的值加入List，当出现如上示例时，不需要再进行检索，而是直接return，减少了时间。</p><pre><code class="python">def twoSum(nums, target):    hashmap = {}    for inx, num1 in enumerate(nums):        if num1 not in hashmap:            hashmap[num1] = [inx]        else:            hashmap[num1].extend([inx])    for key, values in hashmap.items():        num2 = target - key        if num2 in hashmap:            inx2 = hashmap[num2]            if len(inx2) == 1 and inx2 != values:                values.extend(inx2)                return values            elif len(inx2) &gt; 1:                return inx2    return []</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点云笔记(一)：PointNet</title>
    <link href="undefined2019/12/02/%E7%82%B9%E4%BA%91%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9APointNet/"/>
    <url>2019/12/02/%E7%82%B9%E4%BA%91%E7%AC%94%E8%AE%B0-%E4%B8%80-%EF%BC%9APointNet/</url>
    
    <content type="html"><![CDATA[<h1 id="PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation"><a href="#PointNet-Deep-Learning-on-Point-Sets-for-3D-Classification-and-Segmentation" class="headerlink" title="PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation"></a><div align="center">PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation</div></h1><h2 id="0-Summary"><a href="#0-Summary" class="headerlink" title="0. Summary"></a>0. Summary</h2><p>This paper proposes an end to end architecture to <strong><font color="#4b0082">directly consumes point clouds</font></strong>, which is well respect the <strong><font color="#4b0082">permutation invariance</font></strong> of the input points. It’s unified for applications ranging from object classification, part segmentation, to scene semantic parsing.</p><h2 id="1-Research-Objective"><a href="#1-Research-Objective" class="headerlink" title="1.Research Objective"></a>1.Research Objective</h2><p>Most works in deep learning focus on regular input representations like sequences, images and volumes, not much work has been done in deep learning on point sets. Those methods typically transform point sets data to regular 3D voxel grids or collections of images before feeding them to a deep net architecture. This data representation transformation renders the resulting data unnecessarily voluminous. <strong><font color="#4b0082">They are constrained by the representation power of the features extracted.</font></strong><br>To design a deep network directly consumes point sets, <strong><font color="#4b0082">invariance to permutations and to rigid motions</font></strong> are be considered.</p><h2 id="2-Problem-Statement"><a href="#2-Problem-Statement" class="headerlink" title="2.Problem Statement"></a>2.Problem Statement</h2><ul><li>Input: a set of 3D points  $\langle P_i|i=1,2,…,n\rangle$, $P_i$ is a vector of $(x,y,z)$ coordinate.</li><li>Output: $k$ scores for all the $k$ candidate classes.</li></ul><h2 id="3-Architecture"><a href="#3-Architecture" class="headerlink" title="3.Architecture"></a>3.Architecture</h2><h3 id="1-Unified-Architecture"><a href="#1-Unified-Architecture" class="headerlink" title="(1) Unified Architecture"></a><font color="#0099ff">(1) Unified Architecture</font></h3><ul><li><p><strong>Joint Alignment Network</strong><br>Predict  an affine transformation matrix by a mini-network(T-net) and directly apply this transformation to the coordinates of input points and features extracted.<br>To decrease the difficulty of optimizition, this paper add a regularization term to softmax training loss. The feature transform matrix is constrained to be close to orthogonal matrix:$$L_{reg}=||I-AA^T||^2_F$$</p></li><li><p><strong>Symmetry Function for Unordered Input</strong><br>There are three strategies:</p><ol><li>Sort input into a canonical order;</li><li>Theat the input as a sequence to train an RNN, augment the training data by all kinds of permutations;</li><li>Use a simple symmetric function to aggregate the information from each point: <strong><font color="#4b0082">Max pooling</font></strong></li></ol></li><li><p><strong>Local and Global Information Aggregation</strong><br>Global features can easily satisfy the classification task. However, point segmentation requires a combination of local and global knowledge.<br>Feed global feature back and concatenate it with each of the point features to construct new per point features</p></li></ul><h3 id="2-Part-Segmentation-Architecture"><a href="#2-Part-Segmentation-Architecture" class="headerlink" title="(2) Part Segmentation Architecture"></a><font color="#0099ff">(2) Part Segmentation Architecture</font></h3><ul><li><strong><font color="#4b0082">Add one-hot vector</font></strong> indicating the class of the input to segment all categoties in one time.</li></ul><h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4.Conclusion"></a>4.Conclusion</h2><p>This paper proposes a novel deep neural network to derectly consumes point cloud, using max pooling as symmetry function to maintain the permutation invariance.</p><h2 id="5-Notes"><a href="#5-Notes" class="headerlink" title="5.Notes"></a>5.Notes</h2><ul><li><p>Shared mlp represents the convolution layer, which is weight-shared and local connected.</p></li><li><p>When set input transform matrix with 4*4, which allows rotation along any axis, scale and translation transformation, the net can perform better.</p></li><li><p>Input point features for segmentation are concatenated by local point features and global features. While the sizes of local features are $$[64, 128, 128, 512, 2048, 2048, 16]$$which result new point features with <font color="#4b0082">$4944$</font></p></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/12/01/hello-world/"/>
    <url>2019/12/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>